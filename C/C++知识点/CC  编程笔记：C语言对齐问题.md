# C/C++编程笔记：C语言对齐问题【结构体、栈内存以及位域对齐】

考虑下面的结构体定义：

![image-20220905225316847](http://img.icbai.com/2022/image-20220905225316847.png)

假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。

现在，我们编写一个简单的程序：

![image-20220905225328841](http://img.icbai.com/2022/image-20220905225328841.png)

运行后输出：

![image-20220905225343748](http://img.icbai.com/2022/image-20220905225343748.png)

为什么会这样？这就是字节对齐导致的问题。

本文在参考诸多资料的基础上，详细介绍常见的字节对齐问题。因成文较早，资料来源大多已不可考，敬请谅解。

### 一,什么是字节对齐

现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。

### 二,对齐的原因和作用

不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。

但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。



因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。

此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。

### 三,对齐的分类和准则

主要基于Intel X86架构介绍结构体对齐和栈内存对齐，位域本质上为结构体类型。

对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。

#### 3.1 结构体对齐

在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

字节对齐的问题主要就是针对结构体。

**3.1.1 简单示例**

先看个简单的例子(32位，X86处理器，GCC编译器)：

【例1】设结构体如下定义：

![image-20220905225409313](http://img.icbai.com/2022/image-20220905225409313.png)

已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？

结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。

结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。

**3.1.2 对齐准则**

先来看四个重要的基本概念：

（1）数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。

（2）结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。

（3）指定对齐值：#pragma pack (value)时的指定对齐值value。

（4）数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。

基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。

其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。**结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整**(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

以此分析3.1.1节中的结构体B：

假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。

再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0000~0x0009=10字节，(10＋2)%4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。



之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。

上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。

结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：

（1）结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

（2）结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；

（3）结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。

对于以上规则的说明如下:

（1）编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。

（2）为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。



（3）结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。

【例2】假设4字节对齐，以下程序的输出结果是多少？

![image-20220905225424863](http://img.icbai.com/2022/image-20220905225424863.png)

执行后输出如下：

![image-20220905225435670](http://img.icbai.com/2022/image-20220905225435670.png)

下面来具体分析：

首先char a占用1个字节，没问题。

short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。

char c占用1个字节，没问题。

int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。

char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。

因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。

#### 3.1.3 对齐的隐患

**3.1.3.1 数据类型转换**

代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候：

![image-20220905225450885](http://img.icbai.com/2022/image-20220905225450885.png)

最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。

又如对于3.1.1节的结构体struct B，定义如下函数：

![image-20220905225500667](http://img.icbai.com/2022/image-20220905225500667.png)

在函数体内如果直接访问p->a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p->a的地址很可能不是4的倍数。

如果p的地址不在对齐边界上就可能出问题，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。

解决方式如下：

定义一个此结构的局部变量，用memmove方式将数据拷贝进来。

![image-20220905225512011](http://img.icbai.com/2022/image-20220905225512011.png)

注意：如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定(比如跨CPU输入数据、或指针移位运算出来的数据要特别小心)，则需要这样处理。

用#pragma pack (1)将STRUCT_T定义为1字节对齐方式。

**3.1.3.2 处理器间数据通信**

处理器间通过消息(对于C/C++而言就是结构体)进行通信时，需要注意字节对齐以及字节序的问题。

大多数编译器提供内存对其的选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如C/C++编译器提供的#pragma pack(n) n=1，2，4等，让编译器在生成目标文件时，使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处。

然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。

下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。

对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。

对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行四字节对齐。



数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。顺序安排原则是：四字节的放在最前面，两字节的紧接最后一个四字节成员，一字节紧接最后一个两字节成员，填充字节放在最后。

举例如下：

![image-20220905225523612](http://img.icbai.com/2022/image-20220905225523612.png)

**3.1.3.3 排查对齐问题**

如果出现对齐或者赋值问题可查看：

编译器的字节序大小端设置；

处理器架构本身是否支持非对齐访问；

如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。

**3.1.4 更改对齐方式**

主要是更改C编译器的缺省字节对齐方式。

在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：

使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；

使用伪指令#pragma pack()： 取消自定义字节对齐方式。

另外，还有如下的一种方式(GCC特有语法)：

__attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。

__attribute__ ((packed))：取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。



【注】__attribute__机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。

下面具体针对MS VC/C++ 6.0编译器介绍下如何修改编译器默认对齐值。

VC/C++ IDE环境中，可在[Project]|[Settings]，C/C++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。

VC/C++中的编译选项有/Zp[1|2|4|8|16]，/Zpn表示以n字节边界对齐。n字节边界对齐是指一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。亦即：min(sizeof(member), n)。实际上，1字节边界对齐也就表示结构成员之间没有空洞。

/Zpn选项应用于整个工程，影响所有参与编译的结构体。在Struct member alignment中可选择不同的对齐值来改变编译选项。

在编码时，可用#pragma pack动态修改对齐值。具体语法说明见附录5.3节。

自定义对齐值后要用#pragma pack()来还原，否则会对后面的结构造成影响。

【例3】分析如下结构体C：

![image-20220905225535572](http://img.icbai.com/2022/image-20220905225535572.png)

变量b自身对齐值为1，指定对齐值为2，所以有效对齐值为1，假设C从0x0000开始，则b存放在0x0000，符合0x0000%1= 0；变量a自身对齐值为4，指定对齐值为2，所以有效对齐值为2，顺序存放在0x0002~0x0005四个连续字节中，符合0x0002%2=0。变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006~0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。C的自身对齐值为4，所以其有效对齐值为2。又8%2=0，C只占用0x0000~0x0007的八个字节。所以sizeof(struct C) = 8。

注意，结构体对齐到的字节数并非完全取决于当前指定的pack值，如下：

![img](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzQ2MzY2NTktOGZkMzFlM2Y5YmE4OTc1MC5wbmc/aW1hZ2VNb2dyMi9hdXRvLW9yaWVudC9zdHJpcCU3Q2ltYWdlVmlldzIvMi93LzEyNDA=.jpg)

另外，GNU GCC编译器中按1字节对齐可写为以下形式：

![image-20220905225620188](http://img.icbai.com/2022/image-20220905225620188.png)

此时sizeof(struct C)的值为7。

#### 3.2 栈内存对齐

在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。

【例4】

![image-20220905225629418](http://img.icbai.com/2022/image-20220905225629418.png)

结果如下：

![image-20220905225639213](http://img.icbai.com/2022/image-20220905225639213.png)

可以看出都是对齐到4字节。并且前面的char和short并没有被凑在一起(成4字节)，这和结构体内的处理是不同的。

至于为什么输出的地址值是变小的，这是因为该平台下的栈是倒着“生长”的。

#### 3.3 位域对齐

**3.3.1 位域定义**

有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。

位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。

位域定义与结构定义类似，其形式为：

![image-20220905225655671](http://img.icbai.com/2022/image-20220905225655671.png)

其中位域列表的形式为：

![image-20220905225702088](http://img.icbai.com/2022/image-20220905225702088.png)

位域的使用和结构成员的使用相同，其一般形式为：

![image-20220905225709325](../AppData/Roaming/Typora/typora-user-images/image-20220905225709325.png)

位域允许用各种格式输出。

位域在本质上就是一种结构类型，不过其成员是按二进位分配的。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。

位域的使用主要为下面两种情况：

①当机器可用内存空间较少而使用位域可大量节省内存时。如把结构作为大数组的元素时。

②当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。

**3.3.2 对齐准则**

位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。

C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。

其对齐规则大致为：

（1）如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；

（2）如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；

（3）如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；

（4）如果位域字段之间穿插着非位域字段，则不进行压缩；

（5）整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。

【例5】



位域类型为char，第1个字节仅能容纳下element1和element2，所以element1和element2被压缩到第1个字节中，而element3只能从下一个字节开始。因此sizeof(BitField)的结果为2。

【例6】

![image-20220905225743577](http://img.icbai.com/2022/image-20220905225743577.png)

由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。

【例7】

![image-20220905225750280](http://img.icbai.com/2022/image-20220905225750280.png)

非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。

【例8】

![image-20220905225757933](http://img.icbai.com/2022/image-20220905225757933.png)

位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。

**3.3.3 注意事项**

关于位域操作有几点需要注意：

（1）位域的地址不能访问，因此不允许将&运算符用于位域。不能使用指向位域的指针也不能使用位域的数组(数组是种特殊指针)。

例如，scanf函数无法直接向位域中存储数据：

intmain(void){structBitField1tBit;scanf("%d", &tBit.element2);//error: cannot take address of bit-field 'element2'return0;}

可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。

（2）位域不能作为函数返回的结果。

（3）位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度。例如定义int a:33是不允许的。

（4）位域可以不指定位域名，但不能访问无名的位域。

位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型。例如，char :0表示整个位域向后推一个字节，即该无名位域后的下一个位域从下一个字节开始存放，同理short :0和int :0分别表示整个位域向后推两个和四个字节。

当空位域的长度为具体数值N时(如int :2)，该变量仅用来占位N位。

【例9】

![image-20220905225808221](http://img.icbai.com/2022/image-20220905225808221.png)

结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。

![image-20220905225820169](http://img.icbai.com/2022/image-20220905225820169.png)

长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。

（5）位域的表示范围。

位域的赋值不能超过其可以表示的范围；

位域的类型决定该编码能表示的值的结果。

对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据(原码)。如：

![image-20220905225834152](http://img.icbai.com/2022/image-20220905225834152.png)

（6）带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。

【例10】在VC6下执行下面的代码：

![image-20220905225845772](http://img.icbai.com/2022/image-20220905225845772.png)

输入i值为11，则输出为i = 11, cba = -2 -1 -1。

Intel x86处理器按小字节序存储数据，所以bits中的位域在内存中放置顺序为ccba。当num.i置为11时，bits的最低有效位(即位域a)的值为1，a、b、c按低地址到高地址分别存储为10、1、1(二进制)。

但为什么最后的打印结果是a=-1而不是1？

因为位域a定义的类型signed char是有符号数，所以尽管a只有1位，仍要进行符号扩展。1做为补码存在，对应原码-1。

如果将a、b、c的类型定义为unsigned char，即可得到cba = 2 1 1。1011即为11的二进制数。

注：C语言中，不同的成员使用共同的存储区域的数据构造类型称为联合(或共用体)。联合占用空间的大小取决于类型长度最大的成员。联合在定义、说明和使用形式上与结构体相似。

（7）位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性。因此除非必要否则最好不要使用位域。

（8）尽管使用位域可以节省内存空间，但却增加了处理时间。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。

### 四,总结

让我们回到引言部分的问题。

缺省情况下，C/C++编译器默认将结构、栈中的成员数据进行内存对齐。因此，引言程序输出就变成c1 -> 0, s -> 2, c2 -> 4, i -> 8。

编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致整个结构的尺寸变大。尽管会牺牲一点空间(成员之间有空洞)，但提高了性能。

也正是这个原因，引言例子中sizeof(T_ FOO)为12，而不是8。

总结说来，就是：

（1）在结构体中，综合考虑变量本身和指定的对齐值；

（2）在栈上，不考虑变量本身的大小，统一对齐到4字节。

其实做为一个编程学习者，有一个学习的氛围跟一个交流圈子特别重要这里我推荐一个C语言C++交流QQ群1108152000，不管你是小白还是转行人士欢迎入驻，大家一起交流成长。

微信公众号：C语言编程学习基地